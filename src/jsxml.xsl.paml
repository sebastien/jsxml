<?xml version="1.0" encoding="UTF-8"?>
<xsl::stylesheet(version="1.0",xmlns::xsl="http://www.w3.org/1999/XSL/Transform",xmlns::jsx="https://github.com/sebastien/jsxml")

	# FIXME: The long concatenation of empty arrays. This is major for public release.
	# ("li", {/*jsx:map=/state.items*/},[].concat([_t_item(_)]).concat([].concat(_list()).concat([])})).concat([])])]));
	# TODO: Rewrite documentation for texto and add custom tags for dynamic
	# expansion/compilation of examples.

	# {{{
	#
	# The JSXML Templating language
	# =============================
	#
	# # --
	# # project:   JSXML
	# # url:       https://github.com/sebastien/jsxml
	# # license:   MIT
	# # version:   0.1.0
	# # --
	#
	# JSXML is a set of XSL stylesheets that transform XML into
	# JavaScript code equivalent to JSX. Unlike JSX, JSXML is easy to parse
	# (it uses XML) and can easily be re-targetted to different rendering
	# engines (React, Inferno, D3, etc‥).
	#
	#
	# One of the main drawback of JSX is that it introduces a tight coupling
	# between the JavaScript (the controller) and the HTML code (the view) by
	# enouraging a mix of view code within controller code.
	#
	# JSXML was build to satisfy the following requirements:
	#
	# - Encourage decoupling of view code from controller code
	# - Stay close to a classic HTML/CSS + JavaScript workflow, as opposed to JS/JSX workflow
	# - Abstract from rendering back-end
	# - Leverage open web technologies (XML, XSLT)
	#
	# In practice, JSXML allows you to write X(HT)ML documents that are automatically
	# rendered to an UMD JavaScript module in expanded JSX
	# (using `React.createElement`) that can be readily imported as view.
	#
	# The result is that the view can be written predominently in XML/XHTML
	# and can be dynamically integrated with the controller at runtime using
	# dynamic module loading.
	#
	# A complete JSXML example looks like that:
	#
	# ```xml{4,6,7,9,12,13}
	# <?xml version="1.0" encoding="UTF-8"?>
	# <jsx:Component(xmlns::jsx="https://github.com/sebastien/jsxml",xmlns::on="https://github.com/sebastien/jsxml/actions")
	#    <h1>To do list: 
	#        <jsx:value="this.state.items.length" /> items
	#    <h1>
	#    <ul jsx:map="this.state.items">
	#       <jsx:apply template="item" />
	#    </ul>
	#    <jsx:Template name="item">
	#       <li>
	#         <span class="label">item.name</span>
	#         <span class="priority">item.priority</span>
	#       <li>
	#    </jsx:template>
	# </jsx:Component>
	# ```
	#
	#
	# Quick start
	# -----------
	#
	# Create a file named `view.xml`
	#
	# ```
	# <?xml version="1.0" encoding="UTF-8"?>
	# <?xml-stylesheet type="text/xsl" media="screen" href="https://cdn.rawgit.com/sebastien/jsxml/master/dist/jsxml.xsl"?>
	# <jsx:Component xmlns:jsx="https://github.com/sebastien/jsxml" xmlns::on="https://github.com/sebastien/jsxml/actions">
	#	   Hello, world!
	# </jsx:Component>
	# ```
	#
	# Now open this file using your browser, and you should see the following
	# code:
	# 
	# ```
	# TODO
	# ```
	#
	# If you'd like to convert the XML file through your command line, make
	# sure you have `xsltproc` and `curl` installed and do:
	#
	# ```bash
	# curl 'https://cdn.rawgit.com/sebastien/jsxml/master/dist/jsxml.xsl' > jsxml.xsl
	# xsltproc jsxml.xsl view.xml > view.js
	# ```
	#
	# Now you can directly import the view in your React component:
	#
	# ```javascript{1,6}
	# import {View} from "./view.js";
	# import {ReactComponent} from "react";
	#
	# export class Component extends ReactComponent {
	#	    render(){
	#	       return View(this.state, this);
	#	    }
	# }
	# ```
	#
	# JSXML in a nutshell
	# -------------------
	#
	# 1. Namespaces
	# -------------
	#
	# - **jsxml**:   <https://github.com/sebastien/jsxml> -- base namespace
	# - **on**:      <https://github.com/sebastien/jsxml/extra/on> -- used for event handlers
	# # - **actions**: <https://github.com/sebastien/jsxml/extra/actions> -- use
	#
	# 2. Root
	# -------
	#
	# - [`<jsx:Component>CONTENT‥`](#jsx:Component)
	#   declares a component. This is the *root node* of JSXML.
	#
	# 3. Node content
	# ---------------
	#
	# - [`<jsx:value>`](#jsx:value)
	#   evaluates a (JS) expression and returns its content
	#
	# - [`<jsx:attribute name=>`](#jsx:attribute)
	#     Sets an attribute on the current node.
	#
	# - [`<jsx:style=>`](#jsx:style)
	#     Sets a style property for the current node.
	#
	# - [`<jsx:children>`](#jsx:children)
	#     Inserts the children that might have been passed by a parent
	#     component.
	#
	# - [`<jsx:T>`](#jsx:T)
	#     dynamically translates the given string through the JavaScript
	#     defined `T` function.
	#
	# 4. Control flow
	# ---------------
	#
	# - [`<jsx:for each= in=>`](#jsx:for)
	#     Loops over the values returned by the given expression
	#
	# - [`<jsx:if test=>`](#jsx:if)
	#     Applies the current node only if the condition is true
	#
	# - [`<jsx:elif test=>`](#jsx:if)
	#     Applies a consecutive test right after an `jsx:if>
	#
	# - [`<jsx:else>`](#jsx:else)
	#     Applies the current node if all the other conditions have failed
	#
	# 5. Templates
	# ------------
	#
	# - [`<jsx:Template name=>`](#jsx:Template)
	#     declares a new re-usable snippet within a *component*.
	#
	# - [`<jsx:apply template jsx:map= jsx:each=>`](#jsx:apply)
	#     applies a `jsx:Template` to the current node., optionally
	#     mapping it to the given name.
	# 
	# 6. Modules
	# ----------
	#
	# - [`<jsx:import value from as>`](#jsx:import)
	#     imports an external component so that it can be referenced
	#     using `<jsx:component>`
	#
	# - [`<jsx:component class>`](#jsx:component)
	#     instanciates an imported component.
	#
	# 7. JSXML Attributes
	# --------------------
	#
	# - [`@jsx:map`+`@jsx:each`](#@jsx:map)
	#		Maps the selected items to the contents of the node. Works for both
	#		arrays and objects.
	#
	# - [`@jsx:value`](#@jsx:value)
	#		replaces the element's content with the given value
	#	
	# - [`@jsx:if`](#@jsx:if)
	#		Only add the node if the given condition is valid.
	#
	# - [`@jsx:as`/`@jsx:ref`](#@jsx:as)
	#		creates a reference (accessible in the underlying JavaScript)
	#   to the current rendered node.
	#
	# 8. Special namespace attributes
	# -------------------------------
	#
	# - [`@on:*`](#@on:event)
	#		registers a callback to handle the given event.
	#
	# }}}

	<xsl::output(method=text,encoding=UTF-8,indent=no)

	# Yes, you would not believe this was not part of the original spec
	# <http://stackoverflow.com/questions/9611569/xsl-how-do-you-capitalize-first-letter>
	<xsl::variable(name="LOWERCASE",select="'abcdefghijklmnopqrstuvwxyz'")
	<xsl::variable(name="UPPERCASE",select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'")

	# -------------------------------------------------------------------------
	#
	# JSX SPECIFIC TAGS
	#
	# -------------------------------------------------------------------------

	# {{{
	# 
	# Element reference
	# -----------------
	#
	# }}}

	# ==========================================================================
	# CATCHALLS
	# ==========================================================================
	
	<xsl::template(match="jsx:*")
		<xsl::text:(console.error("&lt;>
		<xsl::value-of(select="name()")
		<xsl::text:&gt;&#x0020;element not supported"))>

	<xsl::template(match="@jsx:*")
		# JSX Attributes are output inbetween comments
		<xsl::text:/*>
		<xsl::value-of(select="name()")
		<xsl::text:=>
		<xsl::value-of(select=".")
		<xsl::text:*/null>

	# ==========================================================================
	# <Component>
	# ==========================================================================

	# {{{
	# 0. <a name=jsx:Component></a>`<jsx:Component name>`
	# ------------------------------------------------------
	# 
	# Declares a new JSX component
	#
	# - `name=NAME` is the variable name to which the created `ReactElement` factory will
	#    be bound. If not specified, it will default to `View`.
	#
	# ```html
	# <jsx:Component name="Button">
	#    <button jsx:text="data.name">Untitled button</button>
	# </jsx:Component>
	# ```
	#
	# }}}
	
	# FIXME: Abstract to support View
	<xsl::template(match="jsx:Component",name="component")
		<xsl::param(name=prefix,select="'exports.'")
		<xsl::param(name=postamble)
			<xsl::call-template(name=umd-postamble)
		<xsl::param(name=preamble)
			<xsl::call-template(name=umd-preamble)
		<xsl::param(name=helpers)
			<xsl::call-template(name=helpers)
		# PREAMBLE
		# TODO: Take a module-type parameter
		<xsl::value-of(select="$preamble")
		<xsl::text:&#x000A;>
		# HELPERS
		<xsl::value-of(select="$helpers")
		# STYLES
		<xsl::text:var STYLES={};>
		<xsl::text:&#x000A;>
		<xsl::for-each(select="//*[@style]")
			<xsl::text:STYLES[">
			<xsl::value-of(select="generate-id(@style)")
			<xsl::text:"]=_parseStyle(">
			<xsl::value-of(select="@style")
			<xsl::text:");>
			<xsl::text:&#x000A;>
		# COMPONENT
		<xsl::call-template(name=comment)
			<xsl::with-param(name=text,select="concat('View', @name)")
		<xsl::value-of(select="$prefix")
		<xsl::choose
			<xsl::when(test="@name")
				<xsl::value-of(select="@name")
			<xsl::otherwise
				<xsl::text:View>
		<xsl::text:=function(data,component){>
		<xsl::text:var state=data;>
		<xsl::apply-templates(select="jsx:Template")
		# We filter out the content we don't want (Templates, imports)
		<xsl::variable(name=content,select="*[not(self::jsx:Template) and not(self::jsx:import)]")
		<xsl::choose
			<xsl::when(test="count($content)=0")
				# Element with no content
				<xsl::text(console.error("Component has no children"))
			<xsl::when(test="count($content)=1")
				# Element with 1 child
				<xsl::text:return (>
				<xsl::apply-templates(select=$content)
				<xsl::text:&#x000A;>
				<xsl::text:)};>
			<xsl::otherwise
				# Element with many children
				<xsl::text:return (React.createElement("div",{"className":"component"},>
				<xsl::for-each(select="$content")
					<xsl::apply-templates(select=".")
					<xsl::if(test="position()!=last()")
						<xsl::text:,>
				<xsl::text:&#x000A;>
				<xsl::text:))};>
		# POSTAMBLE
		# TODO: Take a module-type parameter
		<xsl::text:&#x000A;>
		<xsl::text:&#x000A;>
		<xsl::value-of(select="$postamble")

	# ==========================================================================
	# <jsx:Template>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:Template"></a>`<jsx:Template name params>`
	# --------------------------------------------------------
	# 
	# Defines a named template that can be referenced with [<jsx:apply>](#apply)
	#
	#  - `name` is the name of the template, referenced in `apply`
	#  - *`params`*, the optional parameter names for the template
	#
	# ```html
	# <ul>
	#   <li jsx:map="state.items>
	#     <!-- This is where the template is REFERENCED -->
	#     <jsx:apply template="item" />
	#   </li>
	# </ul>
	# <!-- This is where the template is DECLARED -->
	# <jsx:Template name="item" params="item,index">
	#    <span jsx:value="item.name"  />
	#    <span jsx:value="item.value" />
	#    [<span jsx:value="index + 1" />]
	# </jsx:Template>
	# ```
	# }}}
	<xsl::template(match="jsx:Template")
		<xsl::call-template(name=comment)
			<xsl::with-param(name=text,select="concat('Template ', @name)")
		<xsl::text:var _t_>
		<xsl::variable(name=param)
			<xsl::choose
				<xsl::when(test=@params)
					<xsl::value-of(select="@params")
				<xsl::otherwise
					<xsl::value-of(select="'_'")
		<xsl::value-of(select="@name")
		<xsl::text:=function(>
		<xsl::value-of(select="$param")
		<xsl::text:){return (>
		<xsl::call-template(name=element-children)
		<xsl::text:)};>
		<xsl::text:&#x000A;>

	# ==========================================================================
	# JSX IMPORT
	# ==========================================================================
	# We do nothing here

	# {{{
	# 0. <a name="jsx:import"></a>`<jsx:import name from as>`
	# ----------------------------------------------------
	# 
	# Imports a value from an external module
	#
	# }}}
	
	<xsl::template(match="jsx:import")

	# ==========================================================================
	# <jsx:component>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:component"></a>`<jsx:component jsx:class jsx:ref data options>`
	# -------------------------------------------------------------------------------
	#
	# Instanciates the component with the given `jsx:class` feeding it the given
	# `data` and `options`.
	# 
	# - `jsx:class=NAME` the symbol name of the class that will be instanciated
	# - `data=EXPRESSION?` an expression evaluating to the data that will be
	#    passed to the component.
	# - `options=EXPRESSION?` an expression evaluating to the options that will be
	#    passed to the component (this will set `props` in React).
	#
	# When the `<jsx:component>` is not empty, its content will be passed
	# as children of the component (`props.children` in React).
	#
	# ```
	# <jsx:component jsx:class="SearchBox" jsx:ref="search">
	#    <button>Extra button!</button>
	# </jsx:Component>
	# ```
	# }}}
	
	<xsl::template(match="jsx:component")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		# We warp the CODE into a closure
		<xsl::choose
			<xsl::when(test="@jsx:class")
				<xsl::call-template(name="create-element")
					<xsl::with-param(name="name")
						<xsl::value-of(select="@jsx:class")
			<xsl::otherwise
				<xsl::text:console.error("&lt;jsx:component&gt; tag missing a jsx:class attribute")>


	# ==========================================================================
	# <jsx:apply>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:apply"></a>`<jsx:apply template params>`
	# ---------------------------------------------
	# 
	# Applies the template with the given name. This requires
	# a previously defined `<jsx:Template name=NAME>` tag in
	# the document.
	#
	# ```html
	#    <jsx:apply template="placeholder />
	#    <jsx:Template name="placeholder">Lorem ipsum dolor sit amet‥</jsx:Template>
	# ```
	#
	# Note that you can use the [`jsx:map`](#jsx-map) attribute in
	# the `jsx:apply` element.
	#
	# }}}
	# TODO: Add argument attribute?
	<xsl::template(match="jsx:apply",name="jsx-apply")
		<xsl::variable(name=template,select="@template")
		<xsl::variable(name=argument)
			<xsl::choose
				<xsl::when(test="@params")
					<xsl::value-of(select="@params")
				<xsl::otherwise
					<xsl::text:_>
		<xsl::choose
			<xsl::when(test="//jsx:Template[@name=$template]")
				<xsl::text:(_t_>
				<xsl::value-of(select="$template")
				<xsl::text:(>
				<xsl::value-of(select="$argument")
				<xsl::text:))>
			<xsl::otherwise
				<xsl::text:(console.log.error("Missing &lt;jsx:Template name='>
				<xsl::value-of(select="$template")
				<xsl::text:'&gt;"))>


	# ==========================================================================
	# <jsx:for>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:for"></a>`<jsx:for each in>`
	# -------------------------------------------
	# 
	# Loops over the values defined in `EXPRESSION`, assigning each
	# item to `NAME` (`_` by default). This requires that the given
	# EXPRESSION evaluates to a list.
	#
	# ```html
	#    <ul><jsx:for each="number" in="[1,2,3,4,5]">
	#        <li>
	#           Number: <jsx:value>number</jsx:value>
	#        </li>
	#    </jsx></ul>
	# ```
	#
	# }}}
	<xsl::template(match="jsx:for",name="jsx-for")
		<xsl::choose
			<xsl::when(test="@in")
				<xsl::text:(>
				<xsl::value-of(select="@in")
				<xsl::text:||new Array(0)).map(function(>
				<xsl::choose
					<xsl::when(test="@each")
						<xsl::value-of(select="@each")
					<xsl::otherwise
						<xsl::text:_>
				<xsl::text:,i){return (>
				<xsl::apply-templates(select="*")
				<xsl::text:)})
			<xsl::otherwise
				<xsl::text:console.error("&lt;jsx:for&gt; is missing its `in` attribute")

	# ==========================================================================
	# <jsx:if>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:if"></a>`<jsx:if test>`
	# ------------------------------------
	# 
	# Only applies the nodes below if the condition is true
	#
	# ```html
	#    <jsx:if test="state.items.length &gt 0">
	#        <ul><li jsx:map="state.items>
	#           Item: <jsx:value>_</jsx:value>
	#        </li></ul>
	#    </jsx>
	#    <jsx:else>
	#        No items.
	#    </jsx:else>
	# ```
	#
	# }}}
	<xsl::template(match="jsx:if",name="jsx-if")
		<xsl::param(name="node",select=".")
		<xsl::for-each(select="$node")
			<xsl::choose
				<xsl::when(test="@test")
					<xsl::text:&#x000A;/* &lt;jsx:><xsl::value-of(select="local-name()")><xsl::text: test=><xsl::value-of(select="@test")><xsl::text: &gt;*/ >
					# The test
					<xsl::text:((>
					<xsl::value-of(select="@test")
					<xsl::text:) ? (>
					# The if true
					<xsl::apply-templates(select=*)
					<xsl::text:) : >
					# The elif/else branches
					<xsl::choose
						<xsl::when(test="following-sibling::*[1][self::jsx:elif]")
							<xsl::call-template(name="jsx-if")
								<xsl::with-param(name="node",select="following-sibling::*[1]")
						<xsl::when(test="following-sibling::*[1][self::jsx:else]")
							<xsl::call-template(name="jsx-else")
								<xsl::with-param(name="node",select="following-sibling::*[1]")
						<xsl::otherwise
							<xsl::text:null>
					<xsl::text:)>
					<xsl::text:&#x000A;/* &lt;/jsx:>
					<xsl::value-of(select="local-name()")
					<xsl::text:&gt; */&#x000A;>
				<xsl::otherwise
					# Debug if it's not there
					<xsl::text:console.error("&lt;jsx:>
					<xsl::value-of(select="local-name()")
					<xsl::text:if&gt; is missing its `test` attribute")>

	<xsl::template(name="jsx-else")
		<xsl::param(name="node",select=".")
		<xsl::for-each(select="$node")
			<xsl::text:&#x000A;/* &lt;jsx:else&gt; */>
			<xsl::apply-templates(select="*")
			<xsl::text:&#x000A;/* &lt;/jsx:else&gt; */&#x000A;>

	<xsl::template(match="jsx:else|jsx:elif")
		<xsl::text:/* jsx:>
		<xsl::value-of(select="local-name()")
		<xsl::text: out of scope */>


	# ==========================================================================
	# <jsx:value>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:value"></a>`<jsx:value>`
	# -------------------------------------
	# 
	# Evaluates the given `EXPRESSION` and adds its result to the content
	# of the current node (the parent of the `jsx:value` node).
	#
	# }}}
	
	<xsl::template(match="jsx:value")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		# We warp the CODE into a closure
		<xsl::text:(>
		<xsl::value-of(select="normalize-space(.)")
		<xsl::text:)>

	# ==========================================================================
	# <jsx:attribute>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:attribute"></a>`<jsx:attribute name= when= do=>`
	# ----------------------------------------------------------------
	# 
	# Sets/adds the attribute with the given `name` when the given condition
	# is true.
	#
	# - `name` is the name of the attribute to be set in the current node
	# - `when` is an optional condition to be met for the attribute to be set
	# - `do` is optional and can be either `set` or `add`, defining whether
	#    the attribute value is to be reset of expanded (useful for `class`).
	#
	# The content of the `<jsx:attribute>` element is the `{}`-expression or
	# text value to be used.
	# 
	# <ul class="list>
	#    <jsx:attribute name="class" when="items.length==0" do="add>empty</jsx:attribute>
	#    ‥
	# </ul>
	# }}}
	
	<xsl::template(match="jsx:attribute",name="jsx-attribute")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		# We warp the CODE into a closure
		<xsl::text:/* &lt;jsx:attribute&gt; */
		# The condition @when
		<xsl::if(test="@when")
			<xsl::text:((>
			<xsl::value-of(select="@when")
			<xsl::text:) ? (>
		# The operation @do
		<xsl::text:{add:>
		<xsl::choose
			<xsl::when(test="@do='add'")
				<xsl::text:true>
			<xsl::otherwise
				<xsl::text:false>
		# The attribute name value
		<xsl::text:,name:>
		<xsl::choose
			<xsl::when(test="@name='class'")
				<xsl::text:"className">
			<xsl::when(test="@name")
				<xsl::call-template(name=string-value)
					<xsl::with-param(name=text)
						<xsl::value-of(select="@name")
			<xsl::otherwise
				<xsl::text:console.warn("&lt;jsx:attribute&gt; is missing its @name attribute")
		# The string value
		<xsl::text:,value:>
		<xsl::call-template(name=string-value)
		<xsl::text:}>
		# The condition postamble @when
		<xsl::if(test="@when")
			<xsl::text:) : null)>
		<xsl::text:/* &lt;/jsx:attribute&gt; */

	# {{{
	# 0. <a name="jsx:style"></a>`<jsx:style name= when=>`
	# ----------------------------------------------------------------
	# 
	# Sets the style (CSS) attribute with the given `name` when the given
	# condition is true (if specified).
	#
	# - `name` is the name of the attribute to be set in the current node
	# - `when` is an optional condition to be met for the attribute to be set
	#
	# The content of the `<jsx:attribute>` element is the `{}`-expression or
	# text value to be used.
	# 
	# <path d="M0,0 L100,100">
	#    <jsx:style name="strokeWidth":1.5 * _.strength</jsx:style>
	# </path>
	# }}}
	
	<xsl::template(match="jsx:style",name="jsx-style")
		<xsl::text:/* &lt;jsx:style&gt; */>
		<xsl::text:{name:"style",value:{">
		<xsl::value-of(select="normalize-space(@name)")
		<xsl::text:":(>
		<xsl::value-of(select="normalize-space(.)")
		<xsl::text:)}}>
		<xsl::text:/* &lt;/jsx:style&gt; */

	# ==========================================================================
	# <jsx:children>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:children"></a>`<jsx:children>`
	# -------------------------------------
	# 
	# Inserts the children that might have been passed whe composing
	# the component into another component.
	#
	# Here is how you would define the children of an embedded component:
	#
	# ```html
	# <jsx:component jsx:class="Dialog">
	#    <p>Are you sure you would like to remove this item?</p>
	# </jsx:component>
	# ```
	# 
	# And here is how to use the `<jsx:children>` element
	#
	# ```html
	# <jsx:Component jsx:class="Dialog">
	#    <div class="Dialog">
	#        <div class="message">
	#            <jsx:children />
	#        </div>
	#        <div class="actions">
	#            <button>Yes</button>
	#            <button>No</button>
	#        </div>
	#    </div>
	# </jsx:component>
	# ```
#
	# }}}
	
	<xsl::template(match="jsx:children")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		<xsl::text:/* &lt;jsx:children&gt; */>
		<xsl::text:component.props.children>
		<xsl::text:/* &lt;/jsx:children&gt; */>

	# ==========================================================================
	# <JSX:T>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:T"></a>`<jsx:T>`
	# ------------------------------
	# 
	# Feeds the content of the node through the global JavaScript `T` function.
	# `T` is expected to be `T(text:String,lang:String?):String`. 
	#
	# ```html
	# <jsx:T>Hello, world</jsx:T>
	# ```
	#
	# ```html
	# <jsx:T>{"Hello" + ", world"}<jsx:T>
	# ```
	# }}}
	<xsl::template(match="jsx:T")
		<xsl::if(test="count(*)&gt;0")
			<xsl:text:(console.warn("jsx:T should only contain text nodes")) || >
		<xsl::text:(T(>
		<xsl::call-template(name=string-value)
			<xsl::with-param(name="text")
				<xsl::value-of(select="text()")
		<xsl::text:))>

	# {{{
	# 
	# Attributes reference
	# --------------------
	#
	# }}}

	# ==========================================================================
	# @jsx:map
	# ==========================================================================
	# {{{
	# 0. <a name="@jsx:map"></a>`@jsx:map jsx:each`
	# -------------------------------------------
	# 
	# The current node will be repeated as many times as there are
	# elements in the array returned by `EXPRESSION`. 
	#
	# If `jsx:each` is specified, then the variable with the given `NAME`
	# will be used for iteration, otherwise it defaults to `_`.
	#
	# ```html
	# <ul class="people">
	#     <li class="person" jsx:map="data.people" jsx::with="person">
	#       <!-- The name will be replaced by `Unnamed person` if missing -->
	#       <span class="name" jsx:value="person.name">Unnamed person</span>
	#       <!-- while the age will be empty if the value if missing -->
	#       <span class="age"  jsx:value="person.age"></span>
	#     </li>
	# </div>
	# ```
	#
	# >  Note:
	# >  
	# >  With React, a `key` will be automatically inserted based on the
	# >  index unless a `key` attribute is already there.
	#
	# }}}
	<xsl::template(match="*[@jsx:map]")
		<xsl::text:(>
		<xsl::value-of(select="@jsx:map")
		<xsl::text:||new Array(0))>
		<xsl::text:.map(function(>
		# We extract the jsx:each value
		<xsl::choose
			<xsl::when(test="@jsx:each")
				<xsl::value-of(select=@jsx:each)
			<xsl::otherwise
				<xsl::text:_>
		<xsl::text:,i,l){return>
		<xsl::text:&#x0020;(>
		# We test the type of the element
		<xsl::choose
			# We support jsx:apply
			<xsl::when(test="self::jsx:apply")
				<xsl::call-template(name="jsx-apply")
			# But not other types of jsx: tags
			<xsl::when(test="self::jsx:*")
				<xsl::text:console.error("jsx:map applied to unsupported jsx:>
				<xsl::value-of(select="name()")
				<xsl::text: element")>
			# Otherwise it's a regular element
			<xsl::otherwise
				<xsl::call-template(name="create-element")
					<xsl::with-param(name="key")
						<xsl::text:i>
		<xsl::text:);})>

	# -------------------------------------------------------------------------
	#
	# REGULAR ELEMENTS
	#
	# -------------------------------------------------------------------------

	<xsl::template(match="*",name="create-element")
	# Regular elements have no `jsx:` attribute at all, or if they
	# have, these attributes will be ignored.
		<xsl::param(name="name")
			<xsl::text:">
			<xsl::value-of(select="name()")
			<xsl::text:">
		<xsl::param(name="content")
		<xsl::param(name="key")
		<xsl::variable(name="element")
			<xsl::value-of(select=.)
		<xsl::text:&#x000A;>
		<xsl::text:React.createElement(>
		# 1) ELEMENT NAME
		<xsl::value-of(select="$name")
		<xsl::text:,>
		# 2) ATTRIBUTE VALUES
		# We only zap a few JSX attributes
		# TODO: This won't scale well... we should use variables instead
		<xsl::variable(name="attributes",select="@*[namespace-uri()!='https://github.com/sebastien/jsxml']|@jsx:as|@jsx:ref")
		# TODO: Support jsx:style as well
		# If we have jsx:attribute within the node, then we need to merge the attributes
		<xsl::if(test="jsx:attribute|jsx:style")
			<xsl::text:(_mergeAttributes(>
		<xsl::choose
			<xsl::when(test="$attributes")
				# FIXME: Should not need the {
				<xsl::text:{>
				# We take care of the key if it is not defined
				<xsl::if(test="not(@key) and $key")
					<xsl::text:key:>
					<xsl::value-of(select="$key")
					<xsl::text:,>
				<xsl::for-each(select="$attributes")
					<xsl::choose
						<xsl::when(test="local-name()='style'")
							# We need to have a special handling of @style attributes,
							# because React expects them as a map
							<xsl::text:style:(STYLES[">
							<xsl::value-of(select="generate-id(.)")
							<xsl::text:"])>
						<xsl::otherwise
							# Otherwise we ouput the attribute as-is
							<xsl::apply-templates(select=".")
					# All attributes until last have a trailing comma
					<xsl::if(test="position()!=last()")
						<xsl::text:,>
				<xsl::text:}>
			<xsl::when(test="not(@key) and $key")
				# We take care of the key again
				<xsl::text:{key:>
				<xsl::value-of(select="$key")
				<xsl::text:}>
			<xsl::otherwise
				<xsl::text:null>
		<xsl::if(test="jsx:attribute|jsx:style")
			<xsl::text:,[>
			<xsl::for-each(select="jsx:attribute|jsx:style")
				<xsl::choose
					<xsl::when(test="self::jsx:attribute")
						<xsl::call-template(name=jsx-attribute)
					<xsl::otherwise
						<xsl::call-template(name=jsx-style)
				<xsl::if(test="position()!=last()")
					<xsl::text:,>
			<xsl::text:]))>
		# NOTE: We have a leading paren to support concatenating of children
		<xsl::text:>
		# 3) CHILD NODES
		<xsl::choose
			<xsl::when(test=$content)
				<xsl::text:,>
				<xsl::value-of(select=$content)
			<xsl::otherwise
				<xsl::variable(name="children",select="*[not(self::jsx:import) and not(self::jsx:style) and not(self::jsx:attribute) and not(self::jsx:else) and not(self::jsx:elif)]|text()[string-length(normalize-space(.))>0]")
				<xsl::if(test="count($children)>0")
					<xsl::text:,>
					<xsl::call-template(name="element-children")
						<xsl::with-param(name=children,select="$children")
		<xsl::text:)>

	# ==========================================================================
	# ELEMENT CHILDREN SELECTION
	# ==========================================================================
	# FIXME: I didn't manage to abstract that, the CHILD NODES for-each
	# will complain about the result not being a node-set.
	# <xsl::template(name="select-children")
	# 	# Select the elements that should be used a children of the the curently
	# 	# element
	# 	<xsl::value-of(select="*[not(self::jsx:import) and not(self::jsx:style) and not(self::jsx:attribute) and not(self::jsx:else) and not(self::jsx:elif)]|text()[string-length(normalize-space(.))>0]")

	# ==========================================================================
	# ELEMENT CHILDREN
	# ==========================================================================

	# TODO: This one should be rethought to solve the concat issue
	<xsl::template(name="element-children")
		# We select all child elements and non-empty text nodes
		<xsl::param(name="children",select="*[not(self::jsx:import) and not(self::jsx:style) and not(self::jsx:attribute) and not(self::jsx:else) and not(self::jsx:elif)]|text()[string-length(normalize-space(.))>0]")
		<xsl::for-each(select="$children")
			<xsl::choose
				# == JSX NODE =========================================================
				<xsl::when(test="self::jsx:*")
					<xsl::apply-templates(select=".")
				# == JSX ATTR =========================================================
				<xsl::when(test="@jsx:*")
					<xsl::apply-templates(select=".")
				# == TEXT NODE ========================================================
				<xsl::when(test="self::text()")
					<xsl::call-template(name="string")
				# == ELEMENT  =========================================================
				<xsl::otherwise
					<xsl::apply-templates(select=".")
			# SUFFIX
			<xsl::if(test="position()!=last()")
					<xsl::text:, >

	# NOTE:Disabled for now
	# <xsl::template(name=result-type)
	# # A utility template that returns the type of value returned by the
	# # given node. This is helpful when concatenating child nodes.
	# 	<xsl::choose
	# 		# NOTE: We do per-tag dispatching, for modularity
	# 		<xsl::when(test="self::jsx:value")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::jsx:apply")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::jsx:*")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::text()")
	# 			<xsl::text:text>
	# 		<xsl::otherwise
	# 			<xsl::text:value>

	# ---------------------------------------------------------------------------
	#
	# HELPERS
	#
	# ---------------------------------------------------------------------------

	# ==========================================================================
	# TEXT
	# ==========================================================================
	# Outputs the given text node as a normalized string surrounded
	# by double quotes. It will preserve one trailing whitespace when
	# present.

	<xsl::template(match="text( )",name="string")
		<xsl::text:">
		# FIXME: The `normalize-space` is not ideal as it strips stuff out.
		# What we really want to do is to escape newlines into something else.
		<xsl::variable(name="text")
			<xsl::value-of(select=".")
		# We normalize the string but preserve trailing spaces.
		<xsl::value-of(select="normalize-space($text)")
		# NOTE: An alternative would be to compare the last character of the text
		# with the normalized one, it case it's not a space
		<xsl::if(test="substring(.,string-length(.))=' '")
			<xsl::text: >
		<xsl::text:">

	# ==========================================================================
	# @jsx:as
	# ==========================================================================

	# TODO: document
	<xsl::template(match="@jsx:as|@jsx:ref")
		# jsx@as (jsx@ref for React compat)
		<xsl::text:"ref":>
		# TODO: These should be an expression, not a string
		<xsl::text:">
		<xsl::value-of(select=".")
		<xsl::text:">

	# ==========================================================================
	# @jsx:value
	# ==========================================================================

	# {{{
	# 0. <a name="@jsx:value"></a>`@jsx:value`
	# -------------------------------------------------
	# 
	# The attribute variant of <jsx:value>. Evaluates the given `value`
	# and replaces the current node's content with it *unless* it is
	# null or undefined. In this case, the default content of the node
	# will be used.
	#
	# ```html
	# <div class="person">
	#     <!-- The name will be replaced by `Unnamed person` if missing -->
	#     <span class="name" jsx:value="_.name">Unnamed person</span>
	#     <!-- while the age will be empty if the value if missing -->
	#     <span class="age"  jsx:value="_.age"></span>
	# </div>
	# ```
	#
	# }}}
	<xsl::template(match="*[@jsx:value]")
		<xsl::choose
			<xsl::when(test="@jsx:map")
				<xsl::text:console.error("jsx:value attribute used along jsx:map. Tranform the jsx:value to a child node")
			# Does the node has children? If so we evaluate the expression
			<xsl::when(test="count(*|text())>0")
				<xsl::text:&#x000A;>
				<xsl::text:(function(){var __=>
				<xsl::value-of(select="@jsx:value")
				<xsl::text:;>
				<xsl::text:return (>
				<xsl::call-template(name="create-element")
						<xsl::with-param(name="content")
							<xsl::text: (__ != null &amp;&amp; typeof(__) != 'undefined') ? >
							<xsl::value-of(select="@jsx:value")
							<xsl::text: : [>
							<xsl::call-template(name="element-children")
							<xsl::text:]>
				<xsl::text:)} () )>
				<xsl::text:&#x000A;>
			<xsl::otherwise
				<xsl::call-template(name="create-element")
					<xsl::with-param(name="content")
						<xsl::value-of(select="@jsx:value")

	<xsl::template(match="@*")
		# Generic attributes are output as-is
		<xsl::text:">
		<xsl::value-of(select="local-name()")
		<xsl::text:":>
		<xsl::call-template(name=string-value)

	<xsl::template(match="@*[name()='class']")
		# class attributes are renamed to className
		<xsl::text:">
		<xsl::text:className>
		<xsl::text:":>
		<xsl::call-template(name=string-value)

	<xsl::template(match="@*[substring-before(name(),':')='on']")
		# on: prefixed attributes are capitalized
		<xsl::text:"on>
		<xsl::call-template(name=capitalize)
			<xsl::with-param(name="text",select="local-name()")
		<xsl::text:":>
		<xsl::value-of(select=".")

	# Outputs the attribute value, quoted and escaped excepted when
	# it's surrounded by {}
	<xsl::template(name="string-value")
		<xsl::param(name="text")
			<xsl::value-of(select=".")
		# SEE: http://stackoverflow.com/questions/552762/removing-all-n-r-characters-from-a-node-xslt
		<xsl::choose
			<xsl::when(test="substring($text,1,1)='{' and substring($text,string-length($text),1)='}'")
				<xsl::text:(>
				<xsl::value-of(select="translate(substring($text,2,string-length($text)-2),'&#xA;',' ')")
				<xsl::text:)>
			<xsl::otherwise
				<xsl::text:">
				<xsl::value-of(select="translate(normalize-space($text),'&#xA;', ' ')")
				<xsl::text:">

	# ==========================================================================
	# COMMENTS
	# ==========================================================================

	<xsl::template(name=comment)
		<xsl::param(name=text)
		<xsl::text:&#x000A;>
		<xsl::text:/* >
		<xsl::value-of(select="$text")
		<xsl::text: */>
		<xsl::text:&#x000A;>

	# ==========================================================================
	# STRING
	# ==========================================================================

	<xsl::template(name=capitalize)
		<xsl::param(name=text)
		<xsl::variable(name="head",select="translate(substring($text,1,1), $LOWERCASE, $UPPERCASE)")
		<xsl::variable(name="tail",select="substring($text,2)")
		<xsl::value-of(select="concat($head,$tail)")

	# ==========================================================================
	# PREAMBLE
	# ==========================================================================

	<xsl::template(name=umd-preamble)
		<xsl::variable(name=imports)
			<xsl::for-each(select="//jsx:import")
				<xsl::text:,">
				<xsl::value-of(select=@from)
				<xsl::text:">
		(function (global, factory) {
		if (typeof define === "function" &amp;&amp; define.amd) {
		define(["exports", "react"
		<xsl::value-of(select="$imports")
		], factory);
		} else if (typeof exports !== "undefined") {
		factory(exports, require("react"
		<xsl::value-of(select="$imports")
		));
		} else {
		var mod = {
		exports: {}
		};
		factory(mod.exports, global.uis);
		global.componentEs6 = mod.exports;
		}
		})(this, function (exports, react
		<xsl::for-each(select="//jsx:import")
			<xsl::choose
				<xsl::when(test=@from)
					<xsl::text:, >
					<xsl::value-of(select="translate(@from,'.','_')")
				<xsl::otherwise
					<xsl::text:console.error("jsx:import is missing its from='MODULE' parameter")
		) {
		<xsl::text:&#x000A;>
		"use strict"
		<xsl::text:&#x000A;>
		Object.defineProperty(exports, "__esModule", {value:true});
		var React  = react;
		/* Imported components */
		<xsl::for-each(select="//jsx:import")
			<xsl::choose
				<xsl::when(test=jsx:symbol)
					# Get the @from attribute into a module reference
					<xsl::variable(name="module")
						<xsl::choose
							<xsl::when(test="@from")
								<xsl::value-of(select="translate(@from,'.','_')")
							<xsl::otherwise
								<xsl::text:(console.error("jsx:import tags is missing the from='module' attribute"))
					<xsl::for-each(select=jsx:symbol)
						<xsl::call-template(name=symbol-import)
							<xsl::with-param(name=origin)
								<xsl::value-of(select="$module")
								<xsl::text:.>
								<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::call-template(name=symbol-import)
	
	# ==========================================================================
	# IMPORTS
	# ==========================================================================

	<xsl::template(name="symbol-import")
		<xsl::param(name=name)
			<xsl::choose
				<xsl::when(test=@as)
					<xsl::value-of(select="@as")
				<xsl::when(test=@name)
					<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tag is missing the name='symbol' attribute"))
		<xsl::param(name=origin)
			<xsl::choose
				<xsl::when(test="@from")
					<xsl::value-of(select="translate(@from,'.','_')")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tags is missing the from='module' attribute"))
			<xsl::choose
				<xsl::when(test=@name)
					<xsl::text:.>
					<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tag is missing the name='symbol' attribute"))

		<xsl::text:var >
		<xsl::value-of(select="$name")
		<xsl::text:=>
		<xsl::value-of(select="$origin")
		<xsl::text:;>
		<xsl::text:&#x000A;>

	<xsl::template(name=helpers)
			var _mergeAttributes = function(a,b) {
				var res = (b||[]).reduce(function(r,v){
					if (v) {
						var k=v.name;
						if (k === "style") {
							r[k] = r[k] || {};
							Object.assign(r[k], v.value);
						} else if (v.add) {
							r[k] = r[k] ? r[k] + ' ' + v.value : v.value;
						} else {
							r[k] = v.value;
						}
					}
					return r;
				}, a || {});
				console.log("RES", res);
				return res;
			};
			var _parseStyle = function(style){
				var n = document.createElement("div");
				n.setAttribute("style", style);
				var res = {};
				for (var i=0 ; i&lt;n.style.length ; i++) {
					var k  = n.style[i];
					# We need to to style normalization
					var p  = k.split("-").map(function(v,i){return i == 0 ? v : v[0].toUpperCase() + v.substring(1)}).join("");
					res[p] = n.style[k];
				}
				return res;
			};
			# # The empty list singleton, frozen for safety
			# var _empty = Object.freeze([]);
			# # Determines the type of value
			# var _type  = function(v){
			# if      (v === null)               {return 0}
			# else if (v ==  [])                 {return 0}
			# else if (!v)                       {return 0}
			# else if (v.length== 0)             {return 0}
			# else if (v === true)               {return 1}
			# else if (typeof(v) === "number")   {return 'n'}
			# else if (typeof(v) === "string")   {return 's'}
			# else if (v instanceof Array)       {return 'a'}
			# else if (v instanceof Object)      {return Object.getOwnPropertyNames(v).length > 0 ? 'o' : 0}
			# else                               {return -1}
			# };
			# # Flattens into a list
			# var _flatten = function(){
			# 	var r = [];
			# 	for (var i=0;i&lt;arguments.length;i++) {
			# 		var v=arguments[i];
			# 		if (v instanceof Array) {r=r.concat(v)}
			# 		else {r.push(v)}
			# 	}
			# 	return r;
			# };
			# # Enures that the given value is a list (that can be concatenated)
			# var _list  = function(v){
			# 	switch(_type(v)){
			# 		case 'n':
			# 		case 's':
			# 			return [v];
			# 		case 'a':
			# 			return v;
			# 		case 'o':
			# 			return Object.getOwnPropertyNames(v).map(function(k){return v[k]});
			# 		default:
			# 			return _empty;
			# 	}
			# };

	# ==========================================================================
	# POSTAMBLE
	# ==========================================================================

	<xsl::template(name=umd-postamble)
		});

# EOF - vim: ts=2 sw=2
