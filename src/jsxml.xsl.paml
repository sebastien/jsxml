<?xml version="1.0" encoding="UTF-8"?>
<xsl::stylesheet(version="1.0",xmlns::xsl="http://www.w3.org/1999/XSL/Transform",xmlns::jsx="https://github.com/sebastien/jsxml")

	# FIXME: The long concatenation of empty arrays. This is major for public release.
	# ("li", {/*jsx:map=/state.items*/},[].concat([_t_item(_)]).concat([].concat(_list()).concat([])})).concat([])])]));
	# TODO: Rewrite documentation for texto and add custom tags for dynamic
	# expansion/compilation of examples.

	# {{{
	#
	# The JSXML Templating language
	# =============================
	#
	# # --
	# # project:   JSXML
	# # url:       https://github.com/sebastien/jsxml
	# # license:   MIT
	# # version:   0.0.1
	# # --
	#
	# JSXML is a set of XSL stylesheets that transform XML into
	# JavaScript code equivalent to JSX. Unlike JSX, JSXML is easy to parse
	# (it uses XML) and can easily be re-targetted to different rendering
	# engines (React, Inferno, D3, etc‥).
	#
	#
	# One of the main drawback of JSX is that it introduces a tigh coupling
	# between the JavaScript (the controller) and the HTML code (the view) by
	# enourage you to mix view code within controller code.
	#
	# The JSX XSLT Templates allows you to write XML documents that are automatically
	# rendered to an UMD JavaScript module definining the JSX equivalent
	# (using `React.createElement`) that can be readily imported as view.
	#
	# The result is that the view can be written predominently in XML/XHTML
	# and can be dynamically integrated with the controller at runtime using
	# dynamic module loading.
	#
	# A complete JSXML example looks like that:
	#
	# ```xml{4,6,7,9,12,13}
	# <?xml version="1.0" encoding="UTF-8"?>
	# <jsx:Component(xmlns::jsx="https://github.com/sebastien/jsxml",xmlns::on="https://github.com/sebastien/jsxml/actions")
	#    <h1>To do list: 
	#        <jsx:value="this.state.items.length" /> items
	#    <h1>
	#    <ul jsx:map="this.state.items">
	#       <jsx:apply template="item" />
	#    </ul>
	#    <jsx:Template name="item">
	#       <li>
	#         <span class="label">item.name</span>
	#         <span class="priority">item.priority</span>
	#       <li>
	#    </jsx:template>
	# </jsx:Component>
	# ```
	#
	#
	# Quick start
	# -----------
	#
	# Create a file named `view.xml`
	#
	# ```
	# <?xml version="1.0" encoding="UTF-8"?>
	# <?xml-stylesheet type="text/xsl" media="screen" href="https://cdn.rawgit.com/sebastien/jsxml/master/dist/jsxml.xsl"?>
	# <jsx:Component(xmlns::jsx="https://github.com/sebastien/jsxml",xmlns::on="https://github.com/sebastien/jsxml/actions")
	#	   Hello, world!
	# </jsx:Component>
	# ```
	#
	# Now open this file using your browser, and you should see the following
	# code:
	# 
	# ```
	# TODO
	# ```
	#
	# If you'd like to convert the XML file through your command line, make
	# sure you have `xsltproc` and `curl` installed and do:
	#
	# ```bash
	# curl 'https://cdn.rawgit.com/sebastien/jsxml/master/dist/jsxml.xsl' > jsxml.xsl
	# xsltproc jsxml.xsl view.xml > view.js
	# ```
	#
	# Now you can directly import the view in your React component:
	#
	# ```javascript{1,6}
	# import {View} from "./view.js";
	# import {ReactComponent} from "react";
	#
	# export class Component extends ReactComponent {
	#	    render(){
	#	       return View(this.state, this);
	#	    }
	# }
	# ```
	#
	# JSXML in a nutshell
	# -------------------
	#
	# 1. Namespaces
	# -------------
	#
	# - **jsxml**:   <https://github.com/sebastien/jsxml> -- base namespace
	# - **on**:      <https://github.com/sebastien/jsxml/extra/on> -- used for event handlers
	# # - **actions**: <https://github.com/sebastien/jsxml/extra/actions> -- use
	#
	# 2. Root
	# -------
	#
	# - [`<jsx:Component>CONTENT‥`](#jsx:Component)
	#   declares a component. This is the *root node* of JSXML.
	#
	# 3. Node content
	# ---------------
	#
	# - [`<jsx:value>`](#jsx:value)
	#   evaluates a (JS) expression and returns its content
	#
	# - [`<jsx:attribute name=>`](#jsx:attribute)
	#     Sets an attribute on the current node.
	#
	# - [`<jsx:map value= with=>`](#jsx:map)
	#     Iterates over the given `value`
	#
	# - [`<jsx:T>`](#jsx:T)
	#     dynamically translates the given string through the JavaScript
	#     defined `T` function.
	#
	# 4. Control flow
	# ---------------
	#
	# - [`<jsx:if test=>`](#jsx:if)
	#     Applies the current node only if the condition is true
	#
	# - [`<jsx:elif test=>`](#jsx:if)
	#     Applies a consecutive test right after an `jsx:if>
	#
	# - [`<jsx:else>`](#jsx:else)
	#     Applies the current node if all the other conditions have failed
	#
	# 5. Templates
	# ------------
	#
	# - [`<jsx:Template name=>`](#jsx:Template)
	#     declares a new re-usable snippet within a *component*.
	#
	# - [`<jsx:apply template jsx:map= jsx:with=>`](#jsx:apply)
	#     applies a `jsx:Template` to the current node., optionally
	#     mapping it to the given name.
	# 
	# 6. Modules
	# ----------
	#
	# - [`<jsx:import value from as>`](#jsx:import)
	#     imports an external component so that it can be referenced
	#     using `<jsx:component>`
	#
	# - [`<jsx:component class>`](#jsx:component)
	#     instanciates an imported component.
	#
	# 7. JSXML Attributes
	# --------------------
	#
	# - [`@jsx:map`+`@jsx:with`](#@jsx:map)
	#		Maps the selected items to the contents of the node. Works for both
	#		arrays and objects.
	#
	# - [`@jsx:value`](#@jsx:value)
	#		replaces the element's content with the given value
	#	
	# - [`@jsx:if`](#@jsx:if)
	#		Only add the node if the given condition is valid.
	#
	# - [`@jsx:as`/`@jsx:ref`](#@jsx:as)
	#		creates a reference (accessible in the underlying JavaScript)
	#   to the current rendered node.
	#
	# 8. Special namespace attributes
	# -------------------------------
	#
	# - [`@on:*`](#@on:event)
	#		registers a callback to handle the given event.
	#
	# }}}

	<xsl::output(method=text,encoding=UTF-8,indent=no)

	# Yes, you would not believe this was not part of the original spec
	# <http://stackoverflow.com/questions/9611569/xsl-how-do-you-capitalize-first-letter>
	<xsl::variable(name="LOWERCASE",select="'abcdefghijklmnopqrstuvwxyz'")
	<xsl::variable(name="UPPERCASE",select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'")

	# -------------------------------------------------------------------------
	#
	# JSX SPECIFIC TAGS
	#
	# -------------------------------------------------------------------------

	# {{{
	# 
	# Element reference
	# -----------------
	#
	# }}}

	# ==========================================================================
	# CATCHALLS
	# ==========================================================================
	
	<xsl::template(match="jsx:*")
		<xsl::text:(console.error("&lt;>
		<xsl::value-of(select="name()")
		<xsl::text:&gt;&#x0020;element not supported"))>

	<xsl::template(match="@jsx:*")
		# JSX Attributes are output inbetween comments
		<xsl::text:/*>
		<xsl::value-of(select="name()")
		<xsl::text:=>
		<xsl::value-of(select=".")
		<xsl::text:*/null>

	# ==========================================================================
	# <Component>
	# ==========================================================================

	# {{{
	# 0. <a name=jsx:Component></a>`<jsx:Component name>`
	# ------------------------------------------------------
	# 
	# Declares a new JSX component
	#
	# - `name=NAME` is the variable name to which the created `ReactElement` factory will
	#    be bound. If not specified, it will default to `View`.
	#
	# ```html
	# <jsx:Component name="Button">
	#    <button jsx:text="data.name">Untitled button</button>
	# </jsx:Component>
	# ```
	#
	# }}}
	
	<xsl::template(match="jsx:Component",name="component")
		<xsl::param(name=prefix,select="'exports.'")
		<xsl::param(name=postamble)
			<xsl::call-template(name=umd-postamble)
		<xsl::param(name=preamble)
			<xsl::call-template(name=umd-preamble)
		<xsl::param(name=helpers)
			<xsl::call-template(name=helpers)
		# PREAMBLE
		# TODO: Take a module-type parameter
		<xsl::value-of(select="$preamble")
		<xsl::text:&#x000A;>
		# COMPONENT
		<xsl::call-template(name=comment)
			<xsl::with-param(name=text,select="concat('View', @name)")
		<xsl::value-of(select="$prefix")
		<xsl::choose
			<xsl::when(test="@name")
				<xsl::value-of(select="@name")
			<xsl::otherwise
				<xsl::text:View>
		<xsl::text:=function(data,component){>
		<xsl::text:let state=data;>
		<xsl::apply-templates(select="jsx:Template")
		# We filter out the content we don't want (Templates, imports)
		<xsl::variable(name=content,select="*[not(self::jsx:Template) and not(self::jsx:import)]")
		<xsl::choose
			<xsl::when(test="count($content)=0")
				# Element with no content
				<xsl::text(console.error("Component has no children"))
			<xsl::when(test="count($content)=1")
				# Element with 1 child
				<xsl::text:return (>
				<xsl::apply-templates(select=$content)
				<xsl::text:&#x000A;>
				<xsl::text:)};>
			<xsl::otherwise
				# Element with many children
				<xsl::text:return (React.createElement("div",{"className":"component"},>
				<xsl::for-each(select="$content")
					<xsl::apply-templates(select=".")
					<xsl::if(test="position()!=last()")
						<xsl::text:,>
				<xsl::text:&#x000A;>
				<xsl::text:))};>


		# POSTAMBLE
		# TODO: Take a module-type parameter
		<xsl::text:&#x000A;>
		<xsl::text:&#x000A;>
		<xsl::value-of(select="$postamble")

	# ==========================================================================
	# <jsx:Template>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:Template"></a>`<jsx:Template name param>`
	# --------------------------------------------------------
	# 
	# Defines a named template that can be referenced with [<jsx:apply>](#apply)
	#
	#  - `name` is the name of the template, referenced in `apply`
	#  - *`param`*, the optional parameter name for the given data (`_` by default) 
	#
	# ```html
	# <ul>
	#   <li jsx:map="state.items>
	#     <!-- This is where the template is REFERENCED -->
	#     <jsx:apply template="item" />
	#   </li>
	# </ul>
	# <!-- This is where the template is DECLARED -->
	# <jsx:Template name="item" param="item">
	#    <span jsx:text="item.name" />
	#    <span jsx:text="item.value />
	# </jsx:Template>
	# ```
	# }}}
	<xsl::template(match="jsx:Template")
		<xsl::call-template(name=comment)
			<xsl::with-param(name=text,select="concat('Template ', @name)")
		<xsl::text:var _t_>
		<xsl::variable(name=param)
			<xsl::choose
				<xsl::when(test=@param)
					<xsl::value-of(select="@param")
				<xsl::otherwise
					<xsl::value-of(select="'_'")
		<xsl::value-of(select="@name")
		<xsl::text:=function(>
		<xsl::value-of(select="$param")
		<xsl::text:){return (>
		<xsl::call-template(name=element-children)
		<xsl::text:)};>
		<xsl::text:&#x000A;>

	# ==========================================================================
	# JSX IMPORT
	# ==========================================================================
	# We do nothing here

	# {{{
	# 0. <a name="jsx:import"></a>`<jsx:import name from as>`
	# ----------------------------------------------------
	# 
	# Imports a value from an external module
	#
	# }}}
	
	<xsl::template(match="jsx:import")

	# ==========================================================================
	# <jsx:component>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:component"></a>`<jsx:component jsx:class jsx:ref data options>`
	# -------------------------------------------------------------------------------
	#
	# Instanciates the component with the given `jsx:class` feeding it the given
	# `data` and `options`.
	# 
	# - `jsx:class=NAME` the symbol name of the class that will be instanciated
	# - `data=EXPRESSION?` an expression evaluating to the data that will be
	#    passed to the component.
	# - `options=EXPRESSION?` an expression evaluating to the options that will be
	#    passed to the component (this will set `props` in React).
	#
	# When the `<jsx:component>` is not empty, its content will be passed
	# as children of the component (`props.children` in React).
	#
	# ```
	# <jsx:component jsx:class="SearchBox" jsx:ref="search">
	#    <button>Extra button!</button>
	# </jsx:Component>
	# ```
	# }}}
	
	<xsl::template(match="jsx:component")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		# We warp the CODE into a closure
		<xsl::choose
			<xsl::when(test="@jsx:class")
				<xsl::call-template(name="create-element")
					<xsl::with-param(name="name")
						<xsl::value-of(select="@jsx:class")
			<xsl::otherwise
				<xsl::text:console.error("&lt;jsx:component&gt; tag missing a jsx:class attribute")>


	# ==========================================================================
	# <jsx:apply>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:apply"></a>`<jsx:apply template>`
	# ---------------------------------------------
	# 
	# Applies the template with the given name. This requires
	# a previously defined `<jsx:Template name=NAME>` tag in
	# the document.
	#
	# ```html
	#    <jsx:apply template="placeholder />
	#    <jsx:Template name="placeholder">Lorem ipsum dolor sit amet‥</jsx:Template>
	# ```
	#
	# Note that you can use the [`jsx:map`](#jsx-map) attribute in
	# the `jsx:apply` element.
	#
	# }}}
	# TODO: Add argument attribute?
	<xsl::template(match="jsx:apply",name="jsx-apply")
		<xsl::variable(name=template,select="@template")
		<xsl::variable(name=argument,select="'_'")
		<xsl::choose
			<xsl::when(test="//jsx:Template[@name=$template]")
				<xsl::text:(_t_>
				<xsl::value-of(select="$template")
				<xsl::text:(>
				<xsl::value-of(select="$argument")
				<xsl::text:))>
			<xsl::otherwise
				<xsl::text:(console.log.error("Missing &lt;jsx:Template name='>
				<xsl::value-of(select="$template")
				<xsl::text:'&gt;"))>


	# ==========================================================================
	# <jsx:for>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:for"></a>`<jsx:for each in>`
	# -------------------------------------------
	# 
	# Loops over the values defined in `EXPRESSION`, assigning each
	# item to `NAME` (`_` by default). This requires that the given
	# EXPRESSION evaluates to a list.
	#
	# ```html
	#    <ul><jsx:for each="number" in="[1,2,3,4,5]">
	#        <li>
	#           Number: <jsx:value>number</jsx:value>
	#        </li>
	#    </jsx></ul>
	# ```
	#
	# }}}
	<xsl::template(match="jsx:for",name="jsx-for")
		<xsl::choose
			<xsl::when(test="@in")
				<xsl::text:(>
				<xsl::value-of(select="@in")
				<xsl::text:||new Array(0)).map(function(>
				<xsl::choose
					<xsl::when(test="@each")
						<xsl::value-of(select="@each")
					<xsl::otherwise
						<xsl::text:_>
				<xsl::text:,i){return (>
				<xsl::apply-templates(select="*")
				<xsl::text:)})
			<xsl::otherwise
				<xsl::text:console.error("&lt;jsx:for&gt; is missing its `in` attribute")

	# ==========================================================================
	# <jsx:if>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:if"></a>`<jsx:if test>`
	# ------------------------------------
	# 
	# Only applies the nodes below if the condition is true
	#
	# ```html
	#    <jsx:if test="state.items.length &gt 0">
	#        <ul><li jsx:map="state.items>
	#           Item: <jsx:value>_</jsx:value>
	#        </li></ul>
	#    </jsx>
	#    <jsx:else>
	#        No items.
	#    </jsx:else>
	# ```
	#
	# }}}
	<xsl::template(match="jsx:if",name="jsx-if")
		<xsl::choose
			<xsl::when(test="@test")
				# TODO: Abstract in template
				<xsl::text:&#x000A;>
				<xsl::text:/* &lt;jsx:if test=>
				<xsl::value-of(select="@test")
				<xsl::text: &gt;*/>
				<xsl::text:&#x000A;>
				<xsl::text:((>
				<xsl::value-of(select="@test")
				<xsl::text:) ? (>
				<xsl::apply-templates(select="*")
				<xsl::text:) : null)>
				<xsl::text:&#x000A;>
				<xsl::text:/* &lt;/jsx:if&gt; */>
				<xsl::text:&#x000A;>
			<xsl::otherwise
				<xsl::text:console.error("&lt;jsx:if&gt; is missing its `test` attribute")

	# ==========================================================================
	# <jsx:value>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:value"></a>`<jsx:value>`
	# -------------------------------------
	# 
	# Evaluates the given `EXPRESSION` and adds its result to the content
	# of the current node (the parent of the `jsx:value` node).
	#
	# }}}
	
	<xsl::template(match="jsx:value")
		# NOTE: It would be much easier to use the spread syntax [...(EXPRESSION)]
		# We warp the CODE into a closure
		<xsl::text:(>
		<xsl::value-of(select="normalize-space(.)")
		<xsl::text:)>

	# ==========================================================================
	# <JSX:T>
	# ==========================================================================

	# {{{
	# 0. <a name="jsx:t"></a>`<jsx:t>`
	# ------------------------------
	# 
	# Feeds the content of the node through the global JavaScript `T` function.
	# `T` is expected to be `T(text:String,lang:String?):String`.
	#
	# }}}
	<xsl::template(match="jsx:T")
		<xsl::text:(T(>
		<xsl::apply-templates(select="*")
		<xsl::text:)>
					

	# {{{
	# 
	# Attributes reference
	# --------------------
	#
	# }}}

	# ==========================================================================
	# @jsx:map
	# ==========================================================================
	# {{{
	# 0. <a name="@jsx:map"></a>`@jsx:map jsx:with`
	# -------------------------------------------
	# 
	# The current node will be repeated as many times as there are
	# elements in the array returned by `EXPRESSION`. 
	#
	# If `jsx:with` is specified, then the variable with the given `NAME`
	# will be used for iteration, otherwise it defaults to `_`.
	#
	#
	# ```html
	# <ul class="people">
	#     <li class="person" jsx:map="data.people" jsx::with="person">
	#       <!-- The name will be replaced by `Unnamed person` if missing -->
	#       <span class="name" jsx:value="person.name">Unnamed person</span>
	#       <!-- while the age will be empty if the value if missing -->
	#       <span class="age"  jsx:value="person.age"></span>
	#     </li>
	# </div>
	# ```
	#
	# }}}
	<xsl::template(match="*[@jsx:map]")
		<xsl::text:(>
		<xsl::value-of(select="@jsx:map")
		<xsl::text:||new Array(0))>
		<xsl::text:.map(function(>
		# We extract the jsx:with value
		<xsl::choose
			<xsl::when(test="@jsx:with")
				<xsl::value-of(select=@jsx:with)
			<xsl::otherwise
				<xsl::text:_>
		<xsl::text:,i,l){return>
		<xsl::text:&#x0020;(>
		# We test the type of the element
		<xsl::choose
			# We support jsx:apply
			<xsl::when(test="self::jsx:apply")
				<xsl::call-template(name="jsx-apply")
			# But not other types of jsx: tags
			<xsl::when(test="self::jsx:*")
				<xsl::text:console.error("jsx:map applied to unsupported jsx:>
				<xsl::value-of(select="name()")
				<xsl::text: element")>
			# Otherwise it's a regular element
			<xsl::otherwise
				<xsl::call-template(name="create-element")
		<xsl::text:);})>

	# -------------------------------------------------------------------------
	#
	# REGULAR ELEMENTS
	#
	# -------------------------------------------------------------------------

	<xsl::template(match="*",name="create-element")
	# Regular elements have no `jsx:` attribute at all, or if they
	# have, these attributes will be ignored.
		<xsl::param(name="name")
			<xsl::text:">
			<xsl::value-of(select="name()")
			<xsl::text:">
		<xsl::param(name="content")
		<xsl::text:&#x000A;>
		<xsl::text:React.createElement(>
		# 1) ELEMENT NAME
		<xsl::value-of(select="$name")
		<xsl::text:,>
		# 2) ATTRIBUTE VALUES
		# We only zap a few JSX attributes
		# TODO: This won't scale well... we should use variables instead
		<xsl::variable(name="attributes",select="@*[namespace-uri()!='https://github.com/sebastien/jsxml']|@jsx:as|@jsx:ref")
		<xsl::choose
			<xsl::when(test="$attributes")
				# FIXME: Should not need the {
				<xsl::text:{>
				<xsl::for-each(select="$attributes")
					<xsl::apply-templates(select=".")
					<xsl::if(test="position()!=last()")
						<xsl::text:,>
				<xsl::text:}>
			<xsl::otherwise
				<xsl::text:null>
		# NOTE: We have a leading paren to support concatenating of children
		<xsl::text:>
		# 3) CHILD NODES
		<xsl::choose
			<xsl::when(test=$content)
				<xsl::text:,>
				<xsl::value-of(select=$content)
			<xsl::otherwise
				<xsl::variable(name="children",select="*[not(self::jsx:import)]|text()[string-length(normalize-space(.))>0]")
				<xsl::if(test="count($children)>0")
					<xsl::text:,>
					<xsl::call-template(name="element-children")
						<xsl::with-param(name=children,select="$children")
		<xsl::text:)>

	# ==========================================================================
	# ELEMENT CHILDREN
	# ==========================================================================

	# TODO: This one should be rethought to solve the concat issue
	<xsl::template(name="element-children")
		# We select all child elements and non-empty text nodes
		<xsl::param(name="children",select="*[not(self::jsx:import)]|text()[string-length(normalize-space(.))>0]")
		<xsl::for-each(select="$children")
			<xsl::choose
				# == JSX NODE =========================================================
				<xsl::when(test="self::jsx:*")
					<xsl::apply-templates(select=".")
				# == JSX ATTR =========================================================
				<xsl::when(test="@jsx:*")
					<xsl::apply-templates(select=".")
				# == TEXT NODE ========================================================
				<xsl::when(test="self::text()")
					<xsl::call-template(name="string")
				# == ELEMENT  =========================================================
				<xsl::otherwise
					<xsl::apply-templates(select=".")
			# SUFFIX
			<xsl::if(test="position()!=last()")
					<xsl::text:, >

	# NOTE:Disabled for now
	# <xsl::template(name=result-type)
	# # A utility template that returns the type of value returned by the
	# # given node. This is helpful when concatenating child nodes.
	# 	<xsl::choose
	# 		# NOTE: We do per-tag dispatching, for modularity
	# 		<xsl::when(test="self::jsx:value")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::jsx:apply")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::jsx:*")
	# 			<xsl::text:list>
	# 		<xsl::when(test="self::text()")
	# 			<xsl::text:text>
	# 		<xsl::otherwise
	# 			<xsl::text:value>

	# ---------------------------------------------------------------------------
	#
	# HELPERS
	#
	# ---------------------------------------------------------------------------

	# ==========================================================================
	# TEXT
	# ==========================================================================

	<xsl::template(match="text( )",name="string")
		<xsl::text:">
		# FIXME: The `normalize-space` is not ideal as it strips stuff out.
		# What we really want to do is to escape newlines into something else.
		<xsl::variable(name="text")
			<xsl::value-of(select=".")
		# We normalize the string but preserve trailing spaces.
		<xsl::value-of(select="normalize-space($text)")
		# NOTE: An alternative would be to compare the last character of the text
		# with the normalized one, it case it's not a space
		<xsl::if(test="substring(.,string-length(.))=' '")
			<xsl::text: >
		<xsl::text:">

	# ==========================================================================
	# @jsx:as
	# ==========================================================================

	# TODO: document
	<xsl::template(match="@jsx:as|@jsx:ref")
		# jsx@as (jsx@ref for React compat)
		<xsl::text:"ref":>
		# TODO: These should be an expression, not a string
		<xsl::text:">
		<xsl::value-of(select=".")
		<xsl::text:">

	# ==========================================================================
	# @jsx:value
	# ==========================================================================

	# {{{
	# 0. <a name="@jsx:value"></a>`@jsx:value`
	# -------------------------------------------------
	# 
	# The attribute variant of <jsx:value>. Evaluates the given `value`
	# and replaces the current node's content with it *unless* it is
	# null or undefined. In this case, the default content of the node
	# will be used.
	#
	# ```html
	# <div class="person">
	#     <!-- The name will be replaced by `Unnamed person` if missing -->
	#     <span class="name" jsx:value="_.name">Unnamed person</span>
	#     <!-- while the age will be empty if the value if missing -->
	#     <span class="age"  jsx:value="_.age"></span>
	# </div>
	# ```
	#
	# }}}
	<xsl::template(match="*[@jsx:value]")
		<xsl::choose
			<xsl::when(test="@jsx:map")
				<xsl::text:console.error("jsx:value attribute used along jsx:map. Tranform the jsx:value to a child node")
			# Does the node has children? If so we evaluate the expression
			<xsl::when(test="count(*|text())>0")
				<xsl::text:&#x000A;>
				<xsl::text:(function(){let __=>
				<xsl::value-of(select="@jsx:value")
				<xsl::text:;>
				<xsl::text:return (>
				<xsl::call-template(name="create-element")
						<xsl::with-param(name="content")
							<xsl::text: __ ? >
							<xsl::value-of(select="@jsx:value")
							<xsl::text: : [>
							<xsl::call-template(name="element-children")
							<xsl::text:]>
				<xsl::text:)} () )>
				<xsl::text:&#x000A;>
			<xsl::otherwise
				<xsl::call-template(name="create-element")
					<xsl::with-param(name="content")
						<xsl::value-of(select="@jsx:value")

	<xsl::template(match="@*")
		# Generic attributes are output as-is
		<xsl::text:">
		<xsl::value-of(select="local-name()")
		<xsl::text:":>
		<xsl::call-template(name=attribute-value)

	<xsl::template(match="@*[name()='class']")
		# class attributes are renamed to className
		<xsl::text:">
		<xsl::text:className>
		<xsl::text:":>
		<xsl::call-template(name=attribute-value)

	<xsl::template(match="@*[substring-before(name(),':')='on']")
		# on: prefixed attributes are capitalized
		<xsl::text:"on>
		<xsl::call-template(name=capitalize)
			<xsl::with-param(name="text",select="local-name()")
		<xsl::text:":>
		<xsl::value-of(select=".")

	# Outputs the attribute value, quoted and escaped excepted when
	# it's surrounded by {}
	<xsl::template(name="attribute-value")
		<xsl::variable(name="text")
			<xsl::value-of(select=".")
		<xsl::choose
			<xsl::when(test="substring($text,1,1)='{' and substring($text,string-length(.),1)='}'")
				<xsl::text:(>
				<xsl::value-of(select="substring($text,2,string-length(.)-2)")
				<xsl::text:)>
			<xsl::otherwise
				<xsl::text:">
				<xsl::value-of(select=".")
				<xsl::text:">

	# ==========================================================================
	# COMMENTS
	# ==========================================================================

	<xsl::template(name=comment)
		<xsl::param(name=text)
		<xsl::text:&#x000A;>
		<xsl::text:/* >
		<xsl::value-of(select="$text")
		<xsl::text: */>
		<xsl::text:&#x000A;>

	# ==========================================================================
	# STRING
	# ==========================================================================

	<xsl::template(name=capitalize)
		<xsl::param(name=text)
		<xsl::variable(name="head",select="translate(substring($text,1,1), $LOWERCASE, $UPPERCASE)")
		<xsl::variable(name="tail",select="substring($text,2)")
		<xsl::value-of(select="concat($head,$tail)")

	# ==========================================================================
	# PREAMBLE
	# ==========================================================================

	<xsl::template(name=umd-preamble)
		<xsl::variable(name=imports)
			<xsl::for-each(select="//jsx:import")
				<xsl::text:,">
				<xsl::value-of(select=@from)
				<xsl::text:">
		(function (global, factory) {
		if (typeof define === "function" &amp;&amp; define.amd) {
		define(["exports", "react"
		<xsl::value-of(select="$imports")
		], factory);
		} else if (typeof exports !== "undefined") {
		factory(exports, require("react"
		<xsl::value-of(select="$imports")
		));
		} else {
		var mod = {
		exports: {}
		};
		factory(mod.exports, global.uis);
		global.componentEs6 = mod.exports;
		}
		})(this, function (exports, react
		<xsl::for-each(select="//jsx:import")
			<xsl::choose
				<xsl::when(test=@from)
					<xsl::text:, >
					<xsl::value-of(select="translate(@from,'.','_')")
				<xsl::otherwise
					<xsl::text:console.error("jsx:import is missing its from='MODULE' parameter")
		) {
		<xsl::text:&#x000A;>
		"use strict"
		<xsl::text:&#x000A;>
		Object.defineProperty(exports, "__esModule", {value:true});
		var React  = react;
		/* Imported components */
		<xsl::for-each(select="//jsx:import")
			<xsl::choose
				<xsl::when(test=jsx:symbol)
					# Get the @from attribute into a module reference
					<xsl::variable(name="module")
						<xsl::choose
							<xsl::when(test="@from")
								<xsl::value-of(select="translate(@from,'.','_')")
							<xsl::otherwise
								<xsl::text:(console.error("jsx:import tags is missing the from='module' attribute"))
					<xsl::for-each(select=jsx:symbol)
						<xsl::call-template(name=symbol-import)
							<xsl::with-param(name=origin)
								<xsl::value-of(select="$module")
								<xsl::text:.>
								<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::call-template(name=symbol-import)
	
	# ==========================================================================
	# IMPORTS
	# ==========================================================================

	<xsl::template(name="symbol-import")
		<xsl::param(name=name)
			<xsl::choose
				<xsl::when(test=@as)
					<xsl::value-of(select="@as")
				<xsl::when(test=@name)
					<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tag is missing the name='symbol' attribute"))
		<xsl::param(name=origin)
			<xsl::choose
				<xsl::when(test="@from")
					<xsl::value-of(select="translate(@from,'.','_')")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tags is missing the from='module' attribute"))
			<xsl::choose
				<xsl::when(test=@name)
					<xsl::text:.>
					<xsl::value-of(select="@name")
				<xsl::otherwise
					<xsl::text:(console.error("jsx:import tag is missing the name='symbol' attribute"))

		<xsl::text:var >
		<xsl::value-of(select="$name")
		<xsl::text:=>
		<xsl::value-of(select="$origin")
		<xsl::text:;>
		<xsl::text:&#x000A;>

	<xsl::template(name=helpers)
			# The empty list singleton, frozen for safety
			var _empty = Object.freeze([]);
			# Determines the type of value
			var _type  = function(v){
			if      (v === null)               {return 0}
			else if (v ==  [])                 {return 0}
			else if (!v)                       {return 0}
			else if (v.length== 0)             {return 0}
			else if (v === true)               {return 1}
			else if (typeof(v) === "number")   {return 'n'}
			else if (typeof(v) === "string")   {return 's'}
			else if (v instanceof Array)       {return 'a'}
			else if (v instanceof Object)      {return Object.getOwnPropertyNames(v).length > 0 ? 'o' : 0}
			else                               {return -1}
			};
			# Flattens into a list
			var _flatten = function(){
				var r = [];
				for (var i=0;i&lt;arguments.length;i++) {
					var v=arguments[i];
					if (v instanceof Array) {r=r.concat(v)}
					else {r.push(v)}
				}
				return r;
			};
			# Enures that the given value is a list (that can be concatenated)
			var _list  = function(v){
				switch(_type(v)){
					case 'n':
					case 's':
						return [v];
					case 'a':
						return v;
					case 'o':
						return Object.getOwnPropertyNames(v).map(function(k){return v[k]});
					default:
						return _empty;
				}
			};

	# ==========================================================================
	# POSTAMBLE
	# ==========================================================================

	<xsl::template(name=umd-postamble)
		});

# EOF - vim: ts=2 sw=2
